# Migrating From Trigger-based Partitioning To Native

This document will cover how to migrate a partition set using the old method of triggers/inheritance/constraints to a partition set using the native features found in PostgreSQL 11+. Note these instructions do not cover migrating to 10 since some key features that make this migration easier were not yet implemented. It is highly recommended to move to 11 or higher if you want to migrate existing partition sets.

Also note that while this migration document is specific to pg_partman, most of the process can be adapted to any partition sets that you may have made for yourself. Also if anyone would like to contribute to automating this migration process using a stored procedure, it would be appreciated. It is planned for development in the future, but there is no ETA at this time. 

We will be using the partition set generated by the trigger-based `test-time-daily` pgtap test.

If your partition set is managed by pg_partman, it's best to turn off automatic maintenance during this process to avoid any issues. If you are manually calling maintenance directly on this parent set via some other scheduler (cron, etc), ensure that is turned off as well.
```
UPDATE partman.part_config SET automatic_maintenance = false WHERE parent_table = 'partman_test.time_taptest_table';
```
If this table is also sub-partitioned, turn maintenance off there as well for all sub-parents. For sub-partitioning you should be able to follow all the same processes here, but you will have to work from the lowest level upward and perform the migration on each sub-parent all the way to the top-level parent.
```
UPDATE partman.part_config_sub SET sub_automatic_maintenance = false WHERE sub_parent = 'partman_test.time_taptest_table';
UPDATE partman.part_config_sub SET sub_automatic_maintenance = false WHERE sub_parent = 'partman_test.time_taptest_table_p2019_12_08';
[...]
```

Next, we need to create a new parent table using native partitioning since you cannot currently convert an existing table into a native partition parent. Note in this case our original table had a primary key on `col1`. Since `col1` is not part of the partition key, native partitiong does not allow us to declare it as a primary key on the top level table. If you still need this as a primary key, pg_partman provides a template table you can set this on, but it will still not enforce uniqueness across the entire partition set, only on a per-child basis similar to how it worked before native.

Please see the `Child Table Property Inheritance` section of `docs/pg_partman.md` for which properties can be set on the native parent and which must be managed via the template table since this varies between PG versions. These include things like indexes, foreign keys and other table properties.
  
```
CREATE TABLE partman_test.time_taptest_table_native 
    (col1 int, col2 text default 'stuff', col3 timestamptz NOT NULL DEFAULT now()) 
    PARTITION BY RANGE (col3);

CREATE INDEX ON partman_test.time_taptest_table_native (col3);
```

Next check what the ownership & privileges on your original table were and ensure they exist on the new parent table. This will ensure all access to the table works the same after the migration. By default with native partitioning, privleges are no longer granted on child tables to provide direct access to them. If you'd like to keep that behavior, set the `inherit_privileges` column in `part_config` (and part_config_sub if needed) to true. 
```
\dt partman_test.time_taptest_table
                     List of relations
    Schema    |        Name        | Type  |     Owner     
--------------+--------------------+-------+---------------
 partman_test | time_taptest_table | table | partman_owner
(1 row)

\dp+ partman_test.time_taptest_table
                                               Access privileges
    Schema    |        Name        | Type  |          Access privileges          | Column privileges | Policies 
--------------+--------------------+-------+-------------------------------------+-------------------+----------
 partman_test | time_taptest_table | table | partman_owner=arwdDxt/partman_owner+|                   | 
              |                    |       | partman_basic=arwd/partman_owner   +|                   | 
              |                    |       | testing=r/partman_owner             |                   | 
(1 row)
```
```
ALTER TABLE partman_test.time_taptest_table_native OWNER TO partman_owner;
GRANT SELECT, INSERT, UPDATE, DELETE ON partman_test.time_taptest_table_native TO partman_basic;
GRANT SELECT ON partman_test.time_taptest_table_native TO testing;
```
This is how our partition set currently looks before migration:
```
keith@keith=# \d+ partman_test.time_taptest_table
                                  Table "partman_test.time_taptest_table"
 Column |           Type           | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+--------------------------+-----------+----------+---------+----------+--------------+-------------
 col1   | integer                  |           | not null |         | plain    |              | 
 col2   | text                     |           |          |         | extended |              | 
 col3   | timestamp with time zone |           | not null | now()   | plain    |              | 
Indexes:
    "time_taptest_table_pkey" PRIMARY KEY, btree (col1)
Triggers:
    time_taptest_table_part_trig BEFORE INSERT ON partman_test.time_taptest_table FOR EACH ROW EXECUTE FUNCTION partman_test.time_taptest_table_part_trig_func()
Child tables: partman_test.time_taptest_table_p2019_12_08,
              partman_test.time_taptest_table_p2019_12_09,
              partman_test.time_taptest_table_p2019_12_10,
              partman_test.time_taptest_table_p2019_12_11,
              partman_test.time_taptest_table_p2019_12_12,
              partman_test.time_taptest_table_p2019_12_13,
              partman_test.time_taptest_table_p2019_12_14,
              partman_test.time_taptest_table_p2019_12_15,
              partman_test.time_taptest_table_p2019_12_16,
              partman_test.time_taptest_table_p2019_12_17,
              partman_test.time_taptest_table_p2019_12_18,
              partman_test.time_taptest_table_p2019_12_19,
              partman_test.time_taptest_table_p2019_12_20,
              partman_test.time_taptest_table_p2019_12_21,
              partman_test.time_taptest_table_p2019_12_22,
              partman_test.time_taptest_table_p2019_12_23,
              partman_test.time_taptest_table_p2019_12_24
Access method: heap
```

It is best to halt all activity on the given table during the migration process to avoid any issues. This can be done by either revoking all permissions to the table temporarily or by taking out an exclusive lock on the parent table and running all of these steps in a single transaction. The transactional method is highly recommended for the simple fact that if you run into any issues before you've completed the migration process, you can simply rollback and return to the state your database was in before the migration started.
```
BEGIN;
LOCK TABLE partman_test.time_taptest_table IN ACCESS EXCLUSIVE MODE NOWAIT;
```
If this is a subpartitioned table, the lock on the top-level parent should lock out access on all child tables as long as you don't use the ONLY clause.

The first major step in this migration process is now to uninherit all the child tables from the old parent. You can use a query like the one below to generate the ALTER TABLE statements to uninherit all child tables from the given parent table. It's best to use generated SQL like this to avoid typos, especially with very large partition sets:

```
SELECT 'ALTER TABLE '||inhrelid::regclass||' NO INHERIT '||inhparent::regclass||';' FROM pg_inherits WHERE inhparent::regclass = 'partman_test.time_taptest_table'::regclass;

                                              ?column?                                               
-----------------------------------------------------------------------------------------------------
 ALTER TABLE partman_test.time_taptest_table_p2019_12_08 NO INHERIT partman_test.time_taptest_table;
 ALTER TABLE partman_test.time_taptest_table_p2019_12_09 NO INHERIT partman_test.time_taptest_table;
 ALTER TABLE partman_test.time_taptest_table_p2019_12_10 NO INHERIT partman_test.time_taptest_table;
 ALTER TABLE partman_test.time_taptest_table_p2019_12_11 NO INHERIT partman_test.time_taptest_table;
 ALTER TABLE partman_test.time_taptest_table_p2019_12_12 NO INHERIT partman_test.time_taptest_table;
 ALTER TABLE partman_test.time_taptest_table_p2019_12_13 NO INHERIT partman_test.time_taptest_table;
 ALTER TABLE partman_test.time_taptest_table_p2019_12_14 NO INHERIT partman_test.time_taptest_table;
 ALTER TABLE partman_test.time_taptest_table_p2019_12_15 NO INHERIT partman_test.time_taptest_table;
 ALTER TABLE partman_test.time_taptest_table_p2019_12_16 NO INHERIT partman_test.time_taptest_table;
 ALTER TABLE partman_test.time_taptest_table_p2019_12_17 NO INHERIT partman_test.time_taptest_table;
 ALTER TABLE partman_test.time_taptest_table_p2019_12_18 NO INHERIT partman_test.time_taptest_table;
 ALTER TABLE partman_test.time_taptest_table_p2019_12_19 NO INHERIT partman_test.time_taptest_table;
 ALTER TABLE partman_test.time_taptest_table_p2019_12_20 NO INHERIT partman_test.time_taptest_table;
 ALTER TABLE partman_test.time_taptest_table_p2019_12_21 NO INHERIT partman_test.time_taptest_table;
 ALTER TABLE partman_test.time_taptest_table_p2019_12_22 NO INHERIT partman_test.time_taptest_table;
 ALTER TABLE partman_test.time_taptest_table_p2019_12_23 NO INHERIT partman_test.time_taptest_table;
 ALTER TABLE partman_test.time_taptest_table_p2019_12_24 NO INHERIT partman_test.time_taptest_table;
```

For any partition sets, even those not managed by pg_partman, the next step is that you need to figure out the boundary values of your existing child tables and feed those to the ATTACH PARTITION command used in native partitioning. Since pg_partman uses set naming patterns for all the partition types it manages, there is a built-in function (`show_partition_info()`) that can return the boundary values based on the child table's name. Also because the given child table no longer has a parent table after running the above statements, we have to feed that value to the function's `p_parent_table` parameter so it knows how to figure out the proper boundaries. 

For non-pg_partman partition sets you will have to use some other method to figure out these child boundaries.

Again, we can use some sql to generate the commands to re-attach the children to the new parent. This will have to be done for each child table:

TODO See if this can be made into a single query or DO script that can return the command for every child at once.
```
SELECT 'ALTER TABLE partman_test.time_taptest_table_native ATTACH PARTITION partman_test.time_taptest_table_p2019_12_08 FOR VALUES FROM ('||quote_literal(child_start_time)||') TO ('||quote_literal(child_end_time)||');' FROM  partman.show_partition_info('partman_test.time_taptest_table_p2019_12_08', p_parent_table := 'partman_test.time_taptest_table');

SELECT 'ALTER TABLE partman_test.time_taptest_table_native ATTACH PARTITION partman_test.time_taptest_table_p2019_12_09 FOR VALUES FROM ('||quote_literal(child_start_time)||') TO ('||quote_literal(child_end_time)||');' FROM  partman.show_partition_info('partman_test.time_taptest_table_p2019_12_09', p_parent_table := 'partman_test.time_taptest_table');

[...]
SELECT 'ALTER TABLE partman_test.time_taptest_table_native ATTACH PARTITION partman_test.time_taptest_table_p2019_12_24 FOR VALUES FROM ('||quote_literal(child_start_time)||') TO ('||quote_literal(child_end_time)||');' FROM  partman.show_partition_info('partman_test.time_taptest_table_p2019_12_24', p_parent_table := 'partman_test.time_taptest_table');
```

Next is to swap the names of your old trigger-based parent and the new native parent. 
```
ALTER TABLE partman_test.time_taptest_table RENAME TO time_taptest_table_old;
ALTER TABLE partman_test.time_taptest_table_native RENAME TO time_taptest_table;
```
PG11+ supports the feature of a default partition to catch any data that doesn't have a matching child. pg_partman does create this default partition for you when it sets up new partition sets, but since we're migrating we'll have to create one manually if desired. If your table names are particularly long, ensure that adding the `_default` suffix doesn't get truncated unexpectedly. The suffix isn't required for functionality, but provides good context for what the table is for, so it's better to shorten the table name itself to fit the suffix.
```
CREATE TABLE partman_test.time_taptest_table_default (LIKE partman_test.time_taptest_table INCLUDING ALL);
ALTER TABLE partman_test.time_taptest_table ATTACH PARTITION partman_test.time_taptest_table_default DEFAULT;
```
For pg_partman, a template table is used to handle certain inheritance properties, so this table will need to be created. This table can be located in any schema and named whatever you wish, but by default it is created in the same schema that pg_partman was installed to and just prepends `template_` onto the name of the current table including its schema. Also it's good to set the owner to be the same as the parent table owner. Again, if your table names are particularly long, make sure you account for any name truncation if it occurs.

As mentioned above, view the `Child Table Property Inheritance` section of the documention for what properties are managed via this template table depending on your version of PG.
```
CREATE TABLE partman.partman_test_time_taptest_table (LIKE partman_test.time_taptest_table);
ALTER TABLE partman.partman_test_time_taptest_table OWNER TO partman_owner;
```
Because we had a primary key on our original table, and we can't set that on the parent table, this template table can manage that for us.
```
ALTER TABLE partman.partman_test_time_taptest_table ADD PRIMARY KEY (col1);
```
And lastly, for pg_partman, you will need to update the `part_config` (and `part_config_sub` if subpartitioned) tables to account for now being natively partitioned. The value for `template_table` must match the name of the table that was created above.
```
UPDATE partman.part_config SET partition_type = 'native', template_table = 'partman.partman_test_time_taptest_table' WHERE parent_table = 'partman_test.time_taptest_table';
``` 

If you've run this process inside a transaction, be sure to commit your work now
```
COMMIT;
```
This should complete the migration process. If you'd like general calls to `run_maintenance()` to work with this partition set again, be sure to update the `part_config` table to set `automatic_maintenance` back to `true`.
